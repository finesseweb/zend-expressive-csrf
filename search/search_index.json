{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"zend-expressive-csrf Repository abandoned 2019-12-31 This repository has moved to mezzio/mezzio-csrf . Provides CSRF token generation and validation for PSR-7 applications, using zend-expressive-session , and optionally zend-expressive-flash . Installation Run the following to install this library: $ composer require zendframework/zend-expressive-csrf Documentation Documentation is in the doc tree , and can be compiled using mkdocs : $ mkdocs build You may also browse the documentation online .","title":"zend-expressive-csrf"},{"location":"#zend-expressive-csrf","text":"","title":"zend-expressive-csrf"},{"location":"#repository-abandoned-2019-12-31","text":"This repository has moved to mezzio/mezzio-csrf . Provides CSRF token generation and validation for PSR-7 applications, using zend-expressive-session , and optionally zend-expressive-flash .","title":"Repository abandoned 2019-12-31"},{"location":"#installation","text":"Run the following to install this library: $ composer require zendframework/zend-expressive-csrf","title":"Installation"},{"location":"#documentation","text":"Documentation is in the doc tree , and can be compiled using mkdocs : $ mkdocs build You may also browse the documentation online .","title":"Documentation"},{"location":"guard/","text":"CSRF Guards To provide CSRF protection, we provide an abstraction, Zend\\Expressive\\Csrf\\CsrfGuardInterface : namespace Zend\\Expressive\\Csrf; interface CsrfGuardInterface { /** * Generate a CSRF token. * * Typically, implementations should generate a one-time CSRF token, * store it within the session, and return it so that developers may * then inject it in a form, a response header, etc. * * CSRF tokens should EXPIRE after the first hop. */ public function generateToken(string $keyName = '__csrf') : string; /** * Validate whether a submitted CSRF token is the same as the one stored in * the session. * * CSRF tokens should EXPIRE after the first hop. */ public function validateToken(string $token, string $csrfKey = '__csrf') : bool; } Because guards will be backed by different mechanisms, we provide CsrfMiddleware that will generate the guard based on configuration, and inject it into the request passed to later middleware; this approach allows you to separate generation from the guard instance (which is based on request data) from your own middleware. Once you have a concrete implementation, you will generally: Generate a token in middleware displaying a form, and Validate a token in middleware validating that form. As an example, we could have middleware displaying a form as follows: namespace Books; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Diactoros\\Response\\HtmlResponse; use Zend\\Expressive\\Csrf\\CsrfGuardInterface; use Zend\\Expressive\\Csrf\\CsrfMiddleware; use Zend\\Expressive\\Template\\TemplateRendererInterface; class DisplayBookFormHandler implements MiddlewareInterface { private $renderer; public function __construct(TemplateRendererInterface $renderer) { $this->renderer = $renderer; } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { $guard = $request->getAttribute(CsrfMiddleware::GUARD_ATTRIBUTE); $token = $guard->generateToken(); return new HtmlResponse( $this->renderer->render('books::form', [ '__csrf' => $token, ]); ); } } When we're ready to process it, we then might have the following middleware: namespace Books; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Diactoros\\Response\\EmptyResponse; use Zend\\Diactoros\\Response\\HtmlResponse; use Zend\\Expressive\\Csrf\\CsrfGuardInterface; use Zend\\Expressive\\Csrf\\CsrfMiddleware; use Zend\\Expressive\\Template\\TemplateRendererInterface; class ProcessBookFormHandler implements MiddlewareInterface { private $renderer; public function __construct(TemplateRendererInterface $renderer) { $this->renderer = $renderer; } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { $guard = $request->getAttribute(CsrfMiddleware::GUARD_ATTRIBUTE); $data = $request->getParsedBody(); $token = $data['__csrf'] ?? ''; if (! $guard->validateToken($token)) { return new EmptyResponse(412); // Precondition failed } // process form normally and return a response... } } This approach allows you to prevent CSRF attacks separately from normal form validation, which can also simplify how your forms are structured. We provide two guard implementations, one using the base session container functionality from zend-expressive-session, and another using flash messages as provided in zend-expressive-flash. Session-based guard Session-based guards are provided via Zend\\Expressive\\Csrf\\SessionCsrfGuard . This class expects a Zend\\Expressive\\Session\\SessionInterface instance to its constructor, and it then uses that to both store a token in the session during generateToken() , and when validating a submitted token. Flash-based guard Flash guards are provided via Zend\\Expressive\\Csrf\\FlashCsrfGuard . This class expects a Zend\\Expressive\\Flash\\FlashMessagesInterface instance to its constructor, and it then uses that to store a token via a flash message when generateToken() is called, and to retrieve a previously flashed token when validating a submitted token. To use this guard, you will also need to install the zend-expressive-flash package: $ composer require zendframework/zend-expressive-flash Guard factories Because guard implementations generally require request-based artifacts in order to do their work, we provide an interface describing a factory for generating guards. Essentially, each guard implementation will also supply their own factory implementation, which the CsrfMiddleware will then consume to create a guard instance. Zend\\Expressive\\Csrf\\CsrfGuardFactoryInterface defines the following: namespace Zend\\Expressive\\Csrf; use Psr\\Http\\Message\\ServerRequestInterface; interface CsrfGuardFactoryInterface { public function createGuardFromRequest(ServerRequestInterface $request) : CsrfGuardInterface; } We provide the following concrete factories: Zend\\Expressive\\Csrf\\SessionCsrfGuardFactory Zend\\Expressive\\Csrf\\FlashCsrfGuardFactory You will need to map the appropriate one to the Zend\\Expressive\\Csrf\\CsrfGuardFactoryInterface service in your dependency injection container. By default, we map this service to the SessionCsrfGuardFactory . You may also compose the CsrfGuardFactoryInterface directly in your own middleware. When you do, you will have to manually use it to create the guard instance prior to generating or validating a token: class SomeHandler implements MiddlewareInterface { private $guardFactory; public function __construct(CsrfGuardFactoryInterface $guardFactory) { $this->guardFactory = $guardFactory; } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { $guard = $this->guardFactory->createGuardFromRequest($request); // ... } }","title":"CSRF Guards"},{"location":"guard/#csrf-guards","text":"To provide CSRF protection, we provide an abstraction, Zend\\Expressive\\Csrf\\CsrfGuardInterface : namespace Zend\\Expressive\\Csrf; interface CsrfGuardInterface { /** * Generate a CSRF token. * * Typically, implementations should generate a one-time CSRF token, * store it within the session, and return it so that developers may * then inject it in a form, a response header, etc. * * CSRF tokens should EXPIRE after the first hop. */ public function generateToken(string $keyName = '__csrf') : string; /** * Validate whether a submitted CSRF token is the same as the one stored in * the session. * * CSRF tokens should EXPIRE after the first hop. */ public function validateToken(string $token, string $csrfKey = '__csrf') : bool; } Because guards will be backed by different mechanisms, we provide CsrfMiddleware that will generate the guard based on configuration, and inject it into the request passed to later middleware; this approach allows you to separate generation from the guard instance (which is based on request data) from your own middleware. Once you have a concrete implementation, you will generally: Generate a token in middleware displaying a form, and Validate a token in middleware validating that form. As an example, we could have middleware displaying a form as follows: namespace Books; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Diactoros\\Response\\HtmlResponse; use Zend\\Expressive\\Csrf\\CsrfGuardInterface; use Zend\\Expressive\\Csrf\\CsrfMiddleware; use Zend\\Expressive\\Template\\TemplateRendererInterface; class DisplayBookFormHandler implements MiddlewareInterface { private $renderer; public function __construct(TemplateRendererInterface $renderer) { $this->renderer = $renderer; } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { $guard = $request->getAttribute(CsrfMiddleware::GUARD_ATTRIBUTE); $token = $guard->generateToken(); return new HtmlResponse( $this->renderer->render('books::form', [ '__csrf' => $token, ]); ); } } When we're ready to process it, we then might have the following middleware: namespace Books; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Server\\MiddlewareInterface; use Psr\\Http\\Server\\RequestHandlerInterface; use Zend\\Diactoros\\Response\\EmptyResponse; use Zend\\Diactoros\\Response\\HtmlResponse; use Zend\\Expressive\\Csrf\\CsrfGuardInterface; use Zend\\Expressive\\Csrf\\CsrfMiddleware; use Zend\\Expressive\\Template\\TemplateRendererInterface; class ProcessBookFormHandler implements MiddlewareInterface { private $renderer; public function __construct(TemplateRendererInterface $renderer) { $this->renderer = $renderer; } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { $guard = $request->getAttribute(CsrfMiddleware::GUARD_ATTRIBUTE); $data = $request->getParsedBody(); $token = $data['__csrf'] ?? ''; if (! $guard->validateToken($token)) { return new EmptyResponse(412); // Precondition failed } // process form normally and return a response... } } This approach allows you to prevent CSRF attacks separately from normal form validation, which can also simplify how your forms are structured. We provide two guard implementations, one using the base session container functionality from zend-expressive-session, and another using flash messages as provided in zend-expressive-flash.","title":"CSRF Guards"},{"location":"guard/#session-based-guard","text":"Session-based guards are provided via Zend\\Expressive\\Csrf\\SessionCsrfGuard . This class expects a Zend\\Expressive\\Session\\SessionInterface instance to its constructor, and it then uses that to both store a token in the session during generateToken() , and when validating a submitted token.","title":"Session-based guard"},{"location":"guard/#flash-based-guard","text":"Flash guards are provided via Zend\\Expressive\\Csrf\\FlashCsrfGuard . This class expects a Zend\\Expressive\\Flash\\FlashMessagesInterface instance to its constructor, and it then uses that to store a token via a flash message when generateToken() is called, and to retrieve a previously flashed token when validating a submitted token. To use this guard, you will also need to install the zend-expressive-flash package: $ composer require zendframework/zend-expressive-flash","title":"Flash-based guard"},{"location":"guard/#guard-factories","text":"Because guard implementations generally require request-based artifacts in order to do their work, we provide an interface describing a factory for generating guards. Essentially, each guard implementation will also supply their own factory implementation, which the CsrfMiddleware will then consume to create a guard instance. Zend\\Expressive\\Csrf\\CsrfGuardFactoryInterface defines the following: namespace Zend\\Expressive\\Csrf; use Psr\\Http\\Message\\ServerRequestInterface; interface CsrfGuardFactoryInterface { public function createGuardFromRequest(ServerRequestInterface $request) : CsrfGuardInterface; } We provide the following concrete factories: Zend\\Expressive\\Csrf\\SessionCsrfGuardFactory Zend\\Expressive\\Csrf\\FlashCsrfGuardFactory You will need to map the appropriate one to the Zend\\Expressive\\Csrf\\CsrfGuardFactoryInterface service in your dependency injection container. By default, we map this service to the SessionCsrfGuardFactory . You may also compose the CsrfGuardFactoryInterface directly in your own middleware. When you do, you will have to manually use it to create the guard instance prior to generating or validating a token: class SomeHandler implements MiddlewareInterface { private $guardFactory; public function __construct(CsrfGuardFactoryInterface $guardFactory) { $this->guardFactory = $guardFactory; } public function process(ServerRequestInterface $request, RequestHandlerInterface $handler) : ResponseInterface { $guard = $this->guardFactory->createGuardFromRequest($request); // ... } }","title":"Guard factories"},{"location":"intro/","text":"Introduction Cross-Site Request Forgery (CSRF) is a security vector in which an unauthorized request is accepted by a server on behalf of another user; it is essentially an exploit of the trust a site places on a user's browser. The typical mitigation is to create a one-time token that is transmitted as part of the original form, and which must then be transmitted back by the client. This token expires after first submission or after a short amount of time, preventing replays or further submissions. If the token provided does not match what was originally sent, an error should be returned. zend-expressive-csrf provides utilities for both generating CSRF tokens, as well as validating them. Tokens are stored within a session, and expire after any attempt to validate.","title":"Introduction"},{"location":"intro/#introduction","text":"Cross-Site Request Forgery (CSRF) is a security vector in which an unauthorized request is accepted by a server on behalf of another user; it is essentially an exploit of the trust a site places on a user's browser. The typical mitigation is to create a one-time token that is transmitted as part of the original form, and which must then be transmitted back by the client. This token expires after first submission or after a short amount of time, preventing replays or further submissions. If the token provided does not match what was originally sent, an error should be returned. zend-expressive-csrf provides utilities for both generating CSRF tokens, as well as validating them. Tokens are stored within a session, and expire after any attempt to validate.","title":"Introduction"},{"location":"middleware/","text":"CSRF Guard Middleware Since CSRF token generation and validation relies on request artifacts, we provide Zend\\Expressive\\Csrf\\CsrfMiddleware to generate the appropriate guard instance and pass it into a request attribute. This approach allows you to have a single location or specific locations where CSRF guards are generated, which can then be used by any middleware in your application. The CsrfMiddleware has the following constructor arguments: CsrfGuardFactoryInterface $guardFactory : a concrete instance to use for generating the CSRF guard instance. string $attributeKey : the name of the request attribute in which to store the CSRF guard instance. Defaults to the CsrfMiddleware::GUARD_ATTRIBUTE (\"csrf\"). We provide and map a factory for the middleware, Zend\\Expressive\\Csrf\\CsrfMiddlewareFactory ; that factory depends on having the service Zend\\Expressive\\Csrf\\CsrfGuardFactoryInterface defined (by default it is, and points to the SessionCsrfGuard implementation). If you want to override the defaults, create and map a custom factory. Registering the middleware The middleware depends on the Zend\\Expressive\\Session\\SessionMiddleware , and must be piped AFTER that middleware. It can be piped either in the application pipeline, or within routed middleware. As an example, in config/pipeline.php : $app->pipe(\\Zend\\Expressive\\Session\\SessionMiddleware::class); $app->pipe(\\Zend\\Expressive\\Csrf\\CsrfMiddleware::class); Within routed middleware: $app->get('/user/login', [ \\Zend\\Expressive\\Session\\SessionMiddleware::class, \\Zend\\Expressive\\Csrf\\CsrfMiddleware::class, UserLoginFormHandler::class, ]); $app->post('/user/login', [ \\Zend\\Expressive\\Session\\SessionMiddleware::class, \\Zend\\Expressive\\Csrf\\CsrfMiddleware::class, ProcessUserLoginHandler::class, ]);","title":"CSRF Middleware"},{"location":"middleware/#csrf-guard-middleware","text":"Since CSRF token generation and validation relies on request artifacts, we provide Zend\\Expressive\\Csrf\\CsrfMiddleware to generate the appropriate guard instance and pass it into a request attribute. This approach allows you to have a single location or specific locations where CSRF guards are generated, which can then be used by any middleware in your application. The CsrfMiddleware has the following constructor arguments: CsrfGuardFactoryInterface $guardFactory : a concrete instance to use for generating the CSRF guard instance. string $attributeKey : the name of the request attribute in which to store the CSRF guard instance. Defaults to the CsrfMiddleware::GUARD_ATTRIBUTE (\"csrf\"). We provide and map a factory for the middleware, Zend\\Expressive\\Csrf\\CsrfMiddlewareFactory ; that factory depends on having the service Zend\\Expressive\\Csrf\\CsrfGuardFactoryInterface defined (by default it is, and points to the SessionCsrfGuard implementation). If you want to override the defaults, create and map a custom factory.","title":"CSRF Guard Middleware"},{"location":"middleware/#registering-the-middleware","text":"The middleware depends on the Zend\\Expressive\\Session\\SessionMiddleware , and must be piped AFTER that middleware. It can be piped either in the application pipeline, or within routed middleware. As an example, in config/pipeline.php : $app->pipe(\\Zend\\Expressive\\Session\\SessionMiddleware::class); $app->pipe(\\Zend\\Expressive\\Csrf\\CsrfMiddleware::class); Within routed middleware: $app->get('/user/login', [ \\Zend\\Expressive\\Session\\SessionMiddleware::class, \\Zend\\Expressive\\Csrf\\CsrfMiddleware::class, UserLoginFormHandler::class, ]); $app->post('/user/login', [ \\Zend\\Expressive\\Session\\SessionMiddleware::class, \\Zend\\Expressive\\Csrf\\CsrfMiddleware::class, ProcessUserLoginHandler::class, ]);","title":"Registering the middleware"}]}